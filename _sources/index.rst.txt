==========================================================
ざっくりUnixプロセス
==========================================================

| tell-k
| Pycon JP 2018

お前だれよ
=====================================

.. image:: https://pbs.twimg.com/profile_images/775582814871752704/J1TaucBz_400x400.jpg
.. image:: https://dl.dropboxusercontent.com/spa/ghyn87yb4ejn5yy/vxjmiemo.png

* tell-k
* BeProud.inc
* 情弱プログラマー
* https://twitter.com/tell_k
* https://tell-k.github.io/pyconjp2018/

connpass - エンジニアをつなぐIT勉強会支援プラットフォーム 
================================================================

.. figure:: https://dl.dropboxusercontent.com/spa/ghyn87yb4ejn5yy/okbyv2hm.png

   http://connpass.com/

* connpassステッカーあります。ブースにまで是非お越しください。

PyQ - 本気でプログラミングを学びたい人のPythonオンライン学習サービス
========================================================================

.. figure:: https://dl.dropboxusercontent.com/spa/ghyn87yb4ejn5yy/4d694a2da10c437fa0a4b69901f9d754.png
   :width: 80%

   https://pyq.jp/  

* ブースにて **無料体験コードをお配りしています** 。是非お越しください。

TRACERY - システム開発チーム向け知識共有サービス
=====================================================

.. figure:: https://dl.dropboxusercontent.com/spa/ghyn87yb4ejn5yy/b26511423900438399ebbf3c56650781.png
   :width: 80%


* 現在 **鋭意開発中** の新サービスです
* **サービス紹介動画** をブースで流しています。是非お越しください。
* βユーザーを募集しています。


目的/動機
=====================================

* 私はWebアプリを開発するところからプログラマをスタート
* LinuxとかUnix系OSの知識がなくて働き始めは辛かった記憶
* 数年前に読んだ「なるほどUnixプロセス」という本がよかった
* 「あの頃よんでおけばよかった」と思った
* サンプルコードがRubyだったので「じゃぁPythonに置き換えて紹介してみよう」と思った次第です

なるほどUnixプロセス
=====================================

.. image:: https://tatsu-zine.com/images/books/87/cover_l.jpg
   :width: 40%

対象
=====================================

* プログラミングを学び始めた人たち
* この辺の話をすっ飛ばしてしまったここまで辿り着いてしまった僕みたいな人たち
* Unixプロセスとうまいことやっていきたい人たち

目標
=====================================

.. image:: https://kogera-tuntun.com/wp-content/uploads/2018/08/genbaneko.jpg
   :width: 50%

* **なるほど** とは言わないまでも **ざっくりよしわかった** となる感じ 


前提
=====================================

* サンプルコードは Python3.7 です。
* OS は MacOS 10.13.6 です。

目次
==========================================

* システムコール
* プロセス
* プロセスにはIDがある
* プロセスには親がある
* プロセスにはファイルディスクリプタがある
* プロセスにはリソースの制限がある
* プロセスには環境がある
* プロセスには引数がある

目次
==========================================

* プロセスには名前がある
* プロセスには終了コードがある
* プロセスは子プロセスを作れる
* 孤児プロセス
* プロセスは優しい
* プロセスは待てる
* ゾンビプロセス
* デーモンプロセス
* 今日話さなかったこと
* 参考文献
* まとめ

システムコール
===========================

システムコール
===========================

* 基本的にプログラムはCPUの二種類のモードで実行されます。
* **カーネル** と **ユーザーランド**  

  * カーネルモードとよんだりユーザー空間と読んだり、微妙に異なる呼ばれ方をします

* 例えば自分で書いたPythonコードとかはユーザーランドです。
* カーネルはデバイス・ハードウェアとやりとりする中間層

  * ファイルシステム、ネットワーク etc

* デバイス・ハードウェアと直接やりとり可能なのは **カーネル** のみ
* ユーザーランドからカーネルと直接やりとりすることも基本できない
* ユーザーランドからカーネルをやりとりできる仕組みを **システムコール** と呼ぶ

システムコール
================================

.. figure:: https://dl.dropboxusercontent.com/spa/ghyn87yb4ejn5yy/56b6d68275ac4782905ed8833b73c8ac.png
 :width: 100%
 
 via `［試して理解］Linuxのしくみ ～実験と図解で学ぶOSとハードウェアの基礎知識 第2章 > システムコール <http://gihyo.jp/book/2018/978-4-7741-9607-7>`_

システムコール
====================

* システムコールとかの使い方は **man** コマンドで調べられます。
* **open(2)** の **(2)** の部分は man のセクションで、セクション2が **システムコール** です。
* セクション例

  * セクション 1: だれもが実行できるユーザーコマンド
  * セクション 2: システムコール(カーネルが提供する関数) 
  * セクション 3: サブルーチン(C ライブラリ関数)
  * セクション 4: デバイス(/dev ディレクトリのスペシャルファイル)

プロセス
===============

プロセス
===============

* プロセスとはUnixシステムの肝であり原子です。 
* あらゆる **コードはプロセス上で実行されます**
* **プログラムの実行時にプロセスも生まれ、プログラム終了後にプロセスも死にます**
* ずっと生き続けるようなプロセスもある。 -> **デーモンプロセス** (後述)

 * 身近な例だと データベースサーバ、Webサーバとか、専用のプロセスがずっと動いてる

プロセスにはIDがある
===========================

プロセスID
=====================

* ここからはプロセスの性質を簡単に確認しましょう。
* プロセスには固有の識別子( **プロセスID** ) が必ずつけられてます。
* 省略されて ``pid`` と表現されます。
* 例えば Pythonの対話モードで ``os.getpid()`` を実行すると、現在のプロセスIDが確認できる
* os.getpid が システムコール ``getpid(2)`` を実行している
  
.. code-block::python

 >> import os 
 >> os.getpid() 
 16801 # <- プロセスID

プロセスIDの確認
=====================

*  ``ps(1)`` コマンドでそのプロセスの状態を確認できます

.. code-block:: bash
 
 $ ps -p  16801

   PID TTY           TIME CMD
 16801 ttys003    0:00.04 /usr/local/Cellar/python/3.7.0/~省略~/Python

 PID  ... プロセスID
 TTY  ... 仮想端末ファイル
 TIME ... CPU使用時間
 CMD  ... 実行コマンド

プロセスには親がいる
=========================

プロセスには親がいる
=========================

* プロセスには親プロセスがいます。
* ``getppid(2)`` で調べらる

.. code-block:: bash

 >>> import os
 >>> os.getppid()
 14455

* ターミナル起動 -> ターミナルがbashプロンプトを起動
* この場合、bashプロンプトの親プロセスが ターミナル となる

プロセスにはファイルディスクリプタがある
=================================================

ファイルディスクリプタとは？
==============================

* Unixシステムは全てをファイルとして扱う
* ソケットやパイプなどもファイル
* 単純なファイルと区別をつけるためにここでは、総称的なファイルを **リソース** と呼びます
* **ファイルディスクリプタ(ファイル記述子)** とは、リソースを管理するための識別子で、識別するための番号が振られていっます。

プロセスとともに生まれ・死ぬ
================================

* **リソース** を開いた時などにファイルディスクリプタは生成・採番されます。
* 関係ない他のプロセスには共有されない。
* 例えばファイルを開いて ``fileno()`` メソッドで調べるとファイルディスクリプタの番号が確認できます。

.. cod-block:: pycon

 >>> open('test.txt', 'w').fileno()
 3

なぜ3から採番される？
================================

* 同一のプロセスで新たにリソースを開いたり・書いたりしようとすると3から始まる。なぜなのか？
* プロセスは、 **最初から3つのファイルディスクリプタを用意済み** だから

  * 標準入力 ... 0
  * 標準出力 ... 1
  * 標準エラー出力 ... 2 

.. cod-block:: pycon

  >>> import sys
  >>> sys.stdin.fileno()
  0
  >>> sys.stdout.fileno()
  1
  >>> sys.stderr.fileno()
  2

ファイルディスクリプタは再利用される
======================================

* ファイルディスクプリタとして管理するのは openされてるものだけ
* リソースを閉じたりしたら、ファイルディクリプタ番号は再利用される

.. code-block:: pycon

  >>> open('test.txt', mode='r').fileno()
  3
  >>> open('test.txt', mode='r').fileno()
  3
  >>> open('test.txt', mode='r').fileno()
  3

プロセスにはリソースの制限がある
==================================

プロセスにはリソースの制限がある
====================================

* リソースには諸々設定上の上限などがある
* カーネルによって **1プロセス毎** にリソースが制限が設定されてる
* 例えばファイルディスクリプタ数の上限 を確認してみましょう。
* ``resource`` モジュールに諸々掲載されている
* ``getrlimit(2)`` のシステムコール利用して取得できる

.. code-block:: pycon

 >>> import resource
 >>> resource.getrlimit(resource.RLIMIT_NOFILE)
 (4864, 9223372036854775807)

 最初の数字がソフトリミット 
 次の数字がハードリミット 

* ソフトリミットは最低限これくらいまでに抑えて置けば良いという数値
* ハードリミットはなんかありえないくらいデカイ数字

声に出して読みたい日本語
====================================

.. image:: https://dl.dropboxusercontent.com/spa/ghyn87yb4ejn5yy/c11b45b10a284276b07c0cd279b9bd8d.png
   :width: 100%

* ``resource.RLIM_INFINITY`` の数値と一緒
* 上限というよりは、**制限が無い** くらいの意味合い
* 64bitの符号付の整数値の最大値
* 調べると割とポピュラーな数字らしいことがわかります。

制限を変えることもできる
====================================

* ``setrlimit(2)`` を利用
* 試しにファイルディスクリプタの上限数を3にする
* ファイルを一回でも開いたら ``Too may open files.`` というエラーがでる

.. code-block:: pycon

  >>> import resource
  >>> resource.setrlimit(resource.RLIMIT_NOFILE, (3, 3))
  >>> open('test.txt')
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    OSError: [Errno 24] Too many open files: 'test.txt'

プロセスには環境がある
==============================

プロセスには環境がある
==============================

* いわゆる環境変数
* 親プロセスより ``引き継ぎます`` 
* 単純に変更しても親プロセスの環境変数には影響がないです。

::

 $ MESSAGE='pyconjp2018.' python -c "import os; print(os.getenv('MESSAGE'))"
 pyconjp2018

プロセスには引数がある
==============================

* プロセスもといコマンドラインは引数を受け取れます。
* 引数は ``sys.argv`` に実行ファイル名とともに格納されている
* 第一引数に実行ファイル名が格納されています。

.. code-block:: python

 # show_argv.py

 import sys
 print(sys.argv) # 単純に引数を表示するだけ

.. code-block:: bash

  $ python show_argv.py arg1 arg2
  ['show_argv.py', 'arg1', 'arg2']

プロセスには名前がある
==============================

プロセスには名前がある
==============================

* プロセスにほあ名前があり、取得したり、変更したりが可能
* Python では プロセス名は **標準ライブラリでは変更できない**
* py-setproctitle(https://github.com/dvarrazzo/py-setproctitle) というC拡張で変更

プロセスには終了コードがある
==========================================

プロセスには終了コードがある
==========================================

* 0 を返すのが慣習的に **正常終了**
* それ以外を返すのが慣習的に **異常終了**

.. code-block:: python

 exit() #=> 引数無しは0
 exit(1) #=> 異常終了

* 終了時に処理を挟み込むことも可能

.. code-block:: python

 def hello():
    print("hello")

 import atexit
 atexit.register(hello)

via https://docs.python.org/ja/3/library/atexit.html#atexit-example


プロセスは子プロセスを作れる
================================================

プロセスは子プロセスを作れる
================================================

* ``fork(2)`` システムコールで子プロセスが作れる

* 子プロセスは

 * 親プロセスで使われてる全てのメモリーのコピーを引き継ぐ
 * 親プロセスのファイルディスクリプタも引き継ぐ

* Pythonでは ``os.fork`` を利用することで子プロセスを作れます。

実行するとどうなるか?
====================================

.. code-block:: python

  import os
  
  if os.fork():
     print('spam')
  else:
     print('ham')


こうなる
====================================

.. code-block:: bash

  // 実行結果
  spam
  ham

なぜなのか？

* ``fork(2)`` は親プロセスのコピーである
* forkした時点からの処理の実行が分岐する
* 子プロセス での ``os.fork`` の 戻り値は ``0`` になる

確認
====================================

.. code-block:: python

  import os
  
  print(f'親プロセス: {os.getpid()}')
  
  if os.fork(): # <= 子プロセスはここから始まる
     print(f'親プロセス: {os.getpid()}')
  else:
     print(f'子プロセス: {os.getpid()}')

.. code-block:: bash
 
  // 実行結果
  親プロセス: 88220
  親プロセス: 88220
  子プロセス: 88221

孤児プロセス
====================

孤児プロセス
====================

* 子プロセスは端末からの制御( ``Ctrl + C`` )とかは基本受け付けない。
* 親が死んでも子プロセスは生き続けます。
* これを **孤児プロセス** と呼びます。
* 簡単にコードで再現してみるとこうです。

.. code-block:: 

  import os
  import time
  
  if os.fork():
     exit('親プロセスは死んだ') # 親プロセスはforkした瞬間に死ぬ
  
  for i in range(5):
     time.sleep(1)
     print(f'孤児として生きてる {i}')


孤児プロセス - 実行結果
==============================

.. code-block:: bash

  $ python orphan_process.py
  親プロセスは死んだ
  $ 孤児として生きてる 0  <- ここで一旦Terminalに戻る
  孤児として生きてる 1
  孤児として生きてる 2
  孤児として生きてる 3
  孤児として生きてる 4


プロセスは優しい
====================

プロセスは優しい
====================

* ``fork(2)`` は親の完全なコピーを生成する
* メモリ上のデータもコピーするので単純に2倍となる
* 物理的に全てのコピーを最初から用意するのは処理のオーバーヘッドが大きい
* **CoW(Copy on Write)** という仕組みが導入されている
* CoW では参照のみしかない場合には、親も子もメモリー上の同じデータを共有している
* 書き込みが発生した時にだけメモリーコピーする。
* `［試して理解］Linuxのしくみ ～実験と図解で学ぶOSとハードウェアの基礎知識 <http://gihyo.jp/book/2018/978-4-7741-9607-7>`_ 第5章に詳しく乗ってます。

プロセスは待てる
====================

* 親プロセスは、子プロセスが終わるまで待てる
* ``os.wait`` で待つことが可能

.. code-block:: python

   import os
   import time
   
   if os.fork():
      os.wait() # 子プロセスが終了するまで待つ
      exit('親プロセスは死んだ')
   
   for i in range(5):
       time.sleep(1)
       print(f'孤児として生きてる {i}')

::

  # 実行結果
  孤児として生きてる 0
  孤児として生きてる 1
  孤児として生きてる 2
  孤児として生きてる 3
  孤児として生きてる 4
  親プロセスは死んだ

複数のプロセスを待つ
========================

* ``wait`` は子プロセスのが **どれかが終わるまで待つ**

.. code-block:: python

 import os
 import sys
 import time
 import random
 
 for _ in range(3):
     if os.fork() == 0:
         # ランダムで1〜5秒待つ子プロセスを生成する
         time.sleep(random.randint(1, 5))
         sys.exit()
 
 for _ in range(3):
     pid = os.wait()
     print(f'終了プロセスID {pid}')


ゾンビプロセス
========================

ゾンビプロセスとは
======================

* 親プロセスが ``wait`` で子プロセスの終了ステータスを要求しない
* この場合、カーネルは子プロセスの終了情報を、キューとして持ちづける
* 子プロセスの情報は残りづつけるので **リソースの無駄となる**
* このような状態を **ゾンビプロセス** という

ゾンビプロセス確認
=========================

.. code-block:: python

  import os
  import time
  import sys
  
  pid = os.fork()
  if pid == 0:
      time.sleep(1)
      sys.exit()
  
  print(pid) # => 終了した子プロセスID 92763
  time.sleep(10)

.. code-block:: bash

   # 状態を確認する

   $ ps -ho pid,state -p 92763
     PID STAT
   92763 Z+ # <= Z+

孤児とゾンビの違いは？
===========================

* 孤児は先に親が死んでしまったプロセス
* ゾンビは先に自分が死んでwait待ちのプロセス

デーモンプロセス
================================

デーモンプロセス
================================

* 端末から制御されるのではなく、バックグラウンドで動作するプロセス
* Webサーバやデータベースサーバのように常に動作しているようなプロセス
* システム上の一番最初のプロセスは ``init`` プロセス (pid=1, ppid=0)

デーモン化
================================

* デーモン化(``daemonize``)
* デーモン化はプロセスを完全に制御端末やシグナルから切り離したい
* 完全に切り離すために、double fork をするという手法が一般的
* see `デーモン_(ソフトウェア) <https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%83%A2%E3%83%B3_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2)>`_

デーモン化
================================

.. code-block:: python


 # 子プロセス生成
 pid = os.fork()
 if pid > 0:
     # 親死
     sys.exit(0)

 # 子プロセスを制御端末から切り離すk
 os.setsid()

 # 孫プロセス生成 <- 完全に制御端末から切り離される
 pid = os.fork()
 if pid > 0:
     print(f"Daemon PID {pid}")
     sys.exit(0)

 # ディレクトリ消されても動く
 os.chdir('/')
 os.umask(0)

 # デーモンには不要なので標準ストリームを潰す
 devnull = os.open('/dev/null', os.O_RDWR)
 os.dup2(devnull, 0)
 os.dup2(devnull, 1)
 os.dup2(devnull, 2)
 os.close(devnull)

 # デーモン化したい処理
 main()

標準のデーモン化
================================

* PEP 3143 -- Standard daemon process library(https://www.python.org/dev/peps/pep-3143/)
* 一応PEPにはある。ステータスは Deffered(繰越？)
* リファレンス実装が PyPI にあります。

  * https://pypi.org/project/python-daemon/

今日話さなかったこと
=================================

* シグナルの話
* プロセス間通信の話
* 端末プロセスを作る話
* preforkサーバの話

参考書籍
==================================

* なるほどUnixプロセス ― Rubyで学ぶUnixの基礎

  * https://tatsu-zine.com/books/naruhounix

* ［試して理解］Linuxのしくみ ～実験と図解で学ぶOSとハードウェアの基礎知識

  * http://gihyo.jp/book/2018/978-4-7741-9607-7
  * 図と説明がわかりやすく書かれている

* 詳解システムパフォーマンス

  * https://www.oreilly.co.jp/books/9784873117904/
  * パフォーマンスチューニングが主題ですが、基礎的な話がしっかり書かれています。

参考書籍
==================================

* Goならわかるシステムプログラミング

  * https://www.lambdanote.com/products/go 
  * golangにおけるシステムコール周辺の話が充実してます
  * システムコールをモニタリングする方法とかもある

* 詳解Unixプログラミング

  * https://www.amazon.co.jp/dp/B00KRB9U8K/
  * Pythonで学ぶ「詳解 UNIXプログラミング」(その0)
  * https://atsuoishimoto.hatenablog.com/entry/20110307/1299455750

感謝
=====================================

* また参考にさせていただいた資料、本の著者の皆さま。本当ににありがとうございました。
* 参考文献

まとめ
==================================

* プロセスはUnixの原子である。
* あらゆるプログラムはプロセス上で動かす。
* プロセスには様々な特性がある。 


ご静聴ありがとうございました
======================================
